#![feature(let_chains)]

#[cfg(feature = "dhat-heap")]
#[global_allocator]
static ALLOC: dhat::Alloc = dhat::Alloc;

use human_panic::{Metadata, setup_panic};
#[cfg(all(feature = "jemallocator", not(feature = "dhat-heap")))]
use tikv_jemallocator::Jemalloc;

#[cfg(all(feature = "jemallocator", not(feature = "dhat-heap")))]
#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

extern crate clash_lib as clash;

use clap::Parser;
use clash::TokioRuntime;
use std::{
    io::Write,
    path::{Path, PathBuf},
    process::exit,
};

#[derive(Parser)]
#[clap(author, about, long_about = None)]
struct Cli {
    #[clap(short, long, value_parser, value_name = "DIRECTORY")]
    directory: Option<PathBuf>,

    #[clap(
        short,
        long,
        visible_short_aliases = ['f'], // -f is used by clash, it is a compatibility option
        value_parser,
        value_name = "FILE",
        default_value = "config.yaml",
        help = "Specify configuration file"
    )]
    config: PathBuf,
    #[clap(
        short = 't',
        long,
        value_parser,
        default_value = "false",
        help = "Test configuration and exit"
    )]
    test_config: bool,
    #[clap(
        short,
        long,
        visible_short_aliases = ['V'],
        value_parser,
        default_value = "false",
        help = "Print clash-rs version and exit"
    )]
    version: bool,
    #[clap(short, long, help = "Additinally log to file")]
    log_file: Option<String>,

    #[clap(
        long,
        value_parser,
        default_value = "false",
        help = "Enable crash report to help improve clash"
    )]
    help_improve: bool,
}

fn main() {
    #[cfg(feature = "dhat-heap")]
    let _profiler = dhat::Profiler::new_heap();

    let cli = Cli::parse();

    if cli.version {
        println!(
            "{} {}",
            env!("CARGO_PKG_NAME"),
            env!("CLASH_VERSION_OVERRIDE") // Generated by build.rs
        );
        exit(0)
    }

    let file = cli
        .directory
        .as_ref()
        .unwrap_or(&std::env::current_dir().unwrap())
        .join(cli.config)
        .to_string_lossy()
        .to_string();

    if !Path::new(&file).exists() {
        let default_config = "port: 7890";
        let mut config_file = match std::fs::File::create(&file) {
            Ok(config_file) => config_file,
            _ => {
                eprintln!("default profile cannot be created: {}", file);
                exit(1);
            }
        };

        if config_file.write_all(default_config.as_bytes()).is_err() {
            eprintln!("default profile cannot be written: {}", file);
            exit(1);
        };

        println!(
            "the configuration file cannot be found, the template has been created \
             and used: {}",
            file
        );
    }

    if cli.test_config {
        match clash::Config::File(file.clone()).try_parse() {
            Ok(_) => {
                println!("configuration file {} test is successful", file);
                exit(0);
            }
            Err(e) => {
                eprintln!("configuration file {} test failed: {}", file, e);
                exit(1);
            }
        }
    }

    // NOTE: set this up before Sentry
    setup_panic!(
        Metadata::new(env!("CARGO_PKG_NAME"), env!("CARGO_PKG_VERSION"))
            .authors(env!("CARGO_PKG_AUTHORS"))
            .homepage(env!("CARGO_PKG_HOMEPAGE"))
            .support(
                "Open an issue on GitHub: https://github.com/Watfaq/clash-rs/issues"
            )
    );

    let mut _guard = None;
    if cli.help_improve {
        _guard = Some(sentry::init((
            env!("SENTRY_DSN"),
            sentry::ClientOptions {
                release: sentry::release_name!(),
                ..Default::default()
            },
        )));
    }

    match clash::start_scaffold(clash::Options {
        config: clash::Config::File(file),
        cwd: cli.directory.map(|x| x.to_string_lossy().to_string()),
        rt: Some(TokioRuntime::MultiThread),
        log_file: cli.log_file,
    }) {
        Ok(_) => {}
        Err(_) => {
            exit(1);
        }
    }
}
